{"title":"数组、Iterator 和 Generator","uid":"009a4dc3578fc135a4c87ef0cda3d1cd","slug":"Dart&Flutter/Array&Iterator&Genetator","date":"2021-11-10T11:00:10.000Z","updated":"2022-04-19T04:48:28.475Z","comments":true,"path":"api/articles/Dart&Flutter/Array&Iterator&Genetator.json","keywords":null,"cover":"https://hdpublic.youlingxi.cn/6230c6117fd6500a8881d712.","content":"<p>假设有个函数需要返回多项数据，返回值可以选择为数组、<a href=\"https://dart.dev/codelabs/iterables\">Iterator</a> 或者 <a href=\"https://dart.dev/guides/language/language-tour#generators\">Generator</a> 中的任意一个，从结果上看，它们都是可行的。本文探讨它们之间的区别，以及如何选择。</p>\n<p>考虑这样一个场景：你需要在一堆递增序号中，获取基数值，并将它们乘以二后返回，假设数据是 <code>[1, 2, 3, 4, 5]</code>，那么返回值就是 <code>[2, 6, 10]</code>。使用数组完成这个需求的代码是：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>int<span class=\"token punctuation\">></span></span> <span class=\"token function\">arrayAsReturnValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>int<span class=\"token punctuation\">></span></span> input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">final</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>int<span class=\"token punctuation\">></span></span> retValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> num <span class=\"token keyword\">in</span> input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> retValue<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">return</span> retValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>与上述代码执行步数一样，但是使用迭代器的方案，代码如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\"><span class=\"token class-name\">Iterable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>int<span class=\"token punctuation\">></span></span> <span class=\"token function\">iteratorAsReturnValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>int<span class=\"token punctuation\">></span></span> input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> input\n    <span class=\"token punctuation\">.</span><span class=\"token function\">where</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> e <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> e <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看过去最明显的感受是简化了代码、可读性变高了。高阶函数与迭代器的配合使用，为多数编程语言提供了函数式的编程风格，这种方式对于数据处理非常优雅，使代码具有非常高的清晰度。</p>\n<p>迭代器的处理链类似于流水线，并不是同时处理多个数据，而是一个数据走完流程后开始下一个数据处理。</p>\n<p>当你进行链式调用处理数据时，用来处理数据的回调函数没有被调用。也就是说 <code>var result = iteratorAsReturnValue()</code> 这行代码并不会对数据进行处理，此时没有 CPU 消耗，当你真正使用它的时候，迭代器才会开始工作，例如当你调用 <code>result.toList()</code> 的时候。</p>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><p>虽然相对于数组，Iterator 会在使用时执行处理代码，但是还是处理完数据还是会一次性得到结构，如果希望对每个数据项都是按需产生的，就需要使用 Generator。Dart 提供了两种 Generator：</p>\n<ol>\n<li>同步的 Generator 返回 Iterable 对象</li>\n<li>异步的 Generator 返回 Stream 对象</li>\n</ol>\n<p>关于这两种 Generator 的使用方式，可以查看<a href=\"https://dart.dev/guides/language/language-tour#generators\">官方文档</a>，下文中只会以同步 Generator 举例。考虑以下场景：一个显示列表有 100 个可显示的视图，但是用的地方可能不需要这么多。如果用 List 或者 Iterator 的方案，必须生成这 100 个视图。而视图的布局则会浪费大量不必要的 CPU。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">int <span class=\"token function\">buildView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"build view and layout\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token class-name\">Iterable</span> <span class=\"token function\">generateViews</span><span class=\"token punctuation\">(</span>int n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">sync*</span> <span class=\"token punctuation\">&#123;</span>\n  int i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">buildView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token class-name\">Iterable</span> iter <span class=\"token operator\">=</span> <span class=\"token function\">generateViews</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  iter<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行代码查看控制台的输入：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">build view and layout\nbuild view and layout\nbuild view and layout\nbuild view and layout<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Generator 提供了 100 项数据，但是只有 5 次的视图布局，极大的降低了性能消耗。甚至，如果希望下次接着构建第 6 个视图，再次调用 Iterable 的 <code>iter.take(1)</code> 即可。对于异步的执行环境，使用 Generator 能够让 CPU 避开高峰期，使页面上的视觉体验更加流畅。</p>\n","text":"假设有个函数需要返回多项数据，返回值可以选择为数组、Iterator 或者 Generator 中的任意一个，从结果上看，它们都是可行的。本文探讨它们之间的区别，以及如何选择。 考虑这样一个场景：你需要在一堆递增序号中，获取基数值，并将它们乘以二后返回，假设数据是 [1, 2, ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Dart/Flutter","slug":"Dart-Flutter","count":3,"path":"api/categories/Dart-Flutter.json"}],"tags":[{"name":"Dart","slug":"Dart","count":1,"path":"api/tags/Dart.json"},{"name":"编程","slug":"编程","count":1,"path":"api/tags/编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Iterator\"><span class=\"toc-text\">Iterator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Generator\"><span class=\"toc-text\">Generator</span></a></li></ol>","author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CustomSingleChildLayout","uid":"ac9e638e20457c3552fa1b3ae6040913","slug":"Dart&Flutter/CustomSingleChildLayout","date":"2021-11-10T19:00:10.000Z","updated":"2022-04-19T04:48:28.475Z","comments":true,"path":"api/articles/Dart&Flutter/CustomSingleChildLayout.json","keywords":null,"cover":"https://flutter.cn/assets/images/docs/catalog-widget-placeholder.png","text":" CustomSingleChildLayout 可以使其唯一的子节点的布局遵循一个委托。 委托可以确定子组件的布局约束，并决定将子组件放置在何处。委托还可以确定父级的大小，但父类的大小不会取决于子类的大小。 在位置超出布局约束后，子节点依然会被渲染，但是它的手势交互还会停留再原...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Dart/Flutter","slug":"Dart-Flutter","count":3,"path":"api/categories/Dart-Flutter.json"}],"tags":[{"name":"Flutter","slug":"Flutter","count":2,"path":"api/tags/Flutter.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}