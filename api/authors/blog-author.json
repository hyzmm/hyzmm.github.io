{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"理解对象分层","uid":"f44f65f57c1f64f82c0ade6827a7e91d","slug":"gaming-understanding_object_layering","date":"2022-07-11T00:01:32.000Z","updated":"2022-07-17T12:07:09.348Z","comments":true,"path":"api/articles/gaming-understanding_object_layering.json","keywords":null,"cover":"/images/cover/ice_wall_nebula-wallpaper-960x600.jpg","text":"在游戏中，游戏对象要不要与另一个对象产生交互，例如发生碰撞，取决于对象所在 Layer，开发者会决定 Layer 与 Layer 之间是否需要进行碰撞。一个更具体的案例是：敌人会与玩家发生碰撞检测，而敌人之前的相互碰撞会忽略掉。 这通常是基于位运算实现的，每个比特代表一个 Lay...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"编程","slug":"编程","count":2,"path":"api/categories/编程.json"},{"name":"游戏","slug":"编程/游戏","count":1,"path":"api/categories/编程/游戏.json"}],"tags":[{"name":"游戏","slug":"游戏","count":1,"path":"api/tags/游戏.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"字节流 & 比特流","uid":"39424f4d17d0c3bceaf283e3b5c1da2e","slug":"programming-byteStream_and_bit_stream","date":"2022-03-16T22:45:19.000Z","updated":"2022-07-17T12:07:09.348Z","comments":true,"path":"api/articles/programming-byteStream_and_bit_stream.json","keywords":null,"cover":"/images/cover/beautiful_moon_2-wallpaper-960x600.jpg","text":"在前后端的数据交换中，常见的格式有 XML、JSON、GraphQL 和 Protocol Buffers 等，现如今可能更常见到 JSON 格式。大部分情况下 JSON 都是很适用的数据格式，但有些特殊场景，可能希望追求更高的编解码效率和更快的传输速度，放弃那种低效的基于 UT...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"编程","slug":"编程","count":2,"path":"api/categories/编程.json"}],"tags":[{"name":"内存流","slug":"内存流","count":1,"path":"api/tags/内存流.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Flutter 风格指南","uid":"88eb43a0107dd335517e0c4e524ccd07","slug":"flutter-style_guide","date":"2022-02-21T11:58:08.000Z","updated":"2022-07-17T12:07:09.348Z","comments":true,"path":"api/articles/flutter-style_guide.json","keywords":null,"cover":"https://files.flutter-io.cn/cms/static/70760bf1e88b184bb1bc.png","text":" 本文是译文，原文参见原文链接。 长话短说对可读性优化。编写详细的文档。使错误信息更有用。不要使用 timeouts 或 timers。避免使用 is、print、part of、extension 和 _。 概述这篇文档描述了我们设计和编写 Flutter 的方法，上到高级架构...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[{"name":"Dart/Flutter","slug":"Dart-Flutter","count":3,"path":"api/categories/Dart-Flutter.json"}],"tags":[{"name":"Flutter","slug":"Flutter","count":2,"path":"api/tags/Flutter.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"坐标空间转换","uid":"097b62684ec7fde752270b87461aa896","slug":"math-matrix-coordinates_transformation","date":"2021-12-27T11:26:14.000Z","updated":"2022-07-17T12:07:09.348Z","comments":true,"path":"api/articles/math-matrix-coordinates_transformation.json","keywords":null,"cover":"/images/cover/black_hole_8-wallpaper-960x540.jpg","text":"渲染引擎在进行最终的画面绘制时，都需要确定一个子节点应该在屏幕上的什么位置。或者开发者有时还需要知道父节点的一个节点在子空间的什么位置。这些场景需要用到坐标空间的转换，在渲染引擎中，这些空间转换是通过矩阵完成的。例如常见的 toLocal 和 toGlobal 接口所做事情。 子...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数学","slug":"数学","count":1,"path":"api/categories/数学.json"}],"tags":[{"name":"矩阵","slug":"矩阵","count":1,"path":"api/tags/矩阵.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CustomSingleChildLayout","uid":"ac9e638e20457c3552fa1b3ae6040913","slug":"flutter-custom_single_child_layout","date":"2021-11-10T19:00:10.000Z","updated":"2022-07-17T12:07:09.348Z","comments":true,"path":"api/articles/flutter-custom_single_child_layout.json","keywords":null,"cover":"https://flutter.cn/assets/images/docs/catalog-widget-placeholder.png","text":" CustomSingleChildLayout 可以使其唯一的子节点的布局遵循一个委托。 委托可以确定子组件的布局约束，并决定将子组件放置在何处。委托还可以确定父级的大小，但父类的大小不会取决于子类的大小。 在位置超出布局约束后，子节点依然会被渲染，但是它的手势交互还会停留再原...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Dart/Flutter","slug":"Dart-Flutter","count":3,"path":"api/categories/Dart-Flutter.json"}],"tags":[{"name":"Flutter","slug":"Flutter","count":2,"path":"api/tags/Flutter.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"数组、Iterator 和 Generator","uid":"009a4dc3578fc135a4c87ef0cda3d1cd","slug":"dart-array_Iterator_genetator","date":"2021-11-10T11:00:10.000Z","updated":"2022-07-17T12:07:09.348Z","comments":true,"path":"api/articles/dart-array_Iterator_genetator.json","keywords":null,"cover":"/images/cover/red_crow_nebula-wallpaper-960x600.jpg","text":"假设有个函数需要返回多项数据，返回值可以选择为数组、Iterator 或者 Generator 中的任意一个，从结果上看，它们都是可行的。本文探讨它们之间的区别，以及如何选择。 考虑这样一个场景：你需要在一堆递增序号中，获取基数值，并将它们乘以二后返回，假设数据是 [1, 2, ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Dart/Flutter","slug":"Dart-Flutter","count":3,"path":"api/categories/Dart-Flutter.json"}],"tags":[{"name":"Dart","slug":"Dart","count":1,"path":"api/tags/Dart.json"},{"name":"编程","slug":"编程","count":1,"path":"api/tags/编程.json"}],"author":{"name":"皓月之明","slug":"blog-author","avatar":"/images/avatar.jpg","link":"/","description":"进无止境","socials":{"github":"https://github.com/hyzmm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":4,"tags":7,"word_count":"60k","post_count":6}